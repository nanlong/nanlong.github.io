<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1B5EPSJ6ZN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1B5EPSJ6ZN');
</script>

<!-- Matrix Background -->
<canvas id="matrix-bg"></canvas>

<!-- Reading Progress Bar -->
<div id="reading-progress"></div>

<!-- Vignette Effect -->
<div id="vignette"></div>

<style>
    #matrix-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        opacity: 0.08;
    }

    /* Reading Progress Bar */
    #reading-progress {
        position: fixed;
        top: 0;
        left: 0;
        width: 0%;
        height: 3px;
        background: linear-gradient(90deg, #00ff41, #00ff41 50%, #ffffff);
        box-shadow:
            0 0 10px #00ff41,
            0 0 20px #00ff41;
        z-index: 9999;
        transition: width 0.1s ease-out;
    }

    /* Vignette Effect */
    #vignette {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9998;
        background: radial-gradient(
            ellipse at center,
            transparent 60%,
            rgba(0, 0, 0, 0.4) 100%
        );
    }

    /* Code Editor Styles */
    .code-editor {
        background: #1e1e1e;
        border-radius: 8px;
        overflow: hidden;
        font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', Consolas, monospace;
        font-size: 13px;
        line-height: 1.5;
        box-shadow: 0 8px 32px rgba(0, 255, 65, 0.15);
        border: 1px solid #333;
        width: 100%;
        height: 320px;
        margin: 0 auto;
    }

    .editor-header {
        background: #323232;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        border-bottom: 1px solid #333;
        height: 36px;
        box-sizing: border-box;
    }

    .editor-dots {
        display: flex;
        gap: 6px;
    }

    .editor-dots .dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
    }

    .editor-dots .dot.red { background: #ff5f56; }
    .editor-dots .dot.yellow { background: #ffbd2e; }
    .editor-dots .dot.green { background: #27ca40; }

    .editor-title {
        color: #888;
        font-size: 12px;
        flex: 1;
        text-align: center;
    }

    .editor-body {
        display: flex;
        height: calc(100% - 36px);
        overflow: hidden;
    }

    .line-numbers {
        background: #1e1e1e;
        color: #858585;
        text-align: right;
        padding: 12px 8px;
        border-right: 1px solid #333;
        user-select: none;
        white-space: pre;
        min-width: 32px;
    }

    .code-area {
        flex: 1;
        overflow: hidden;
    }

    .code-content {
        padding: 12px 16px;
        white-space: pre;
        color: #d4d4d4;
    }

    /* Syntax Highlighting - Dracula Theme */
    .code-editor .kw { color: #ff79c6; }
    .code-editor .ty { color: #8be9fd; }
    .code-editor .fn { color: #50fa7b; }
    .code-editor .mc { color: #50fa7b; }
    .code-editor .st { color: #f1fa8c; }
    .code-editor .at { color: #ffb86c; }
    .code-editor .cm { color: #6272a4; }
    .code-editor .num { color: #bd93f9; }

    /* Cursor */
    .code-editor .cursor {
        display: inline-block;
        width: 2px;
        height: 1.2em;
        background: #00ff41;
        margin-left: 1px;
        vertical-align: text-bottom;
        animation: blink 1s step-end infinite;
    }

    @keyframes blink {
        0%, 50% { opacity: 1; }
        50.01%, 100% { opacity: 0; }
    }

    /* GitHub å¯¼èˆªæ å›¾æ ‡ */
    #menu li:has(.nav-github) {
        display: flex;
        align-items: center;
    }

    .nav-github {
        display: flex;
        align-items: center;
        height: 100%;
    }

    .nav-github svg {
        transition: color 0.2s ease;
        vertical-align: middle;
    }

    .nav-github:hover svg {
        color: #00ff41;
    }
</style>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        // ========== Matrix Rain Animation ==========
        const canvas = document.getElementById("matrix-bg");
        const ctx = canvas.getContext("2d");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const chars = "01";
        const charArray = chars.split("");
        const fontSize = 20;
        const columns = Math.floor(canvas.width / fontSize / 3);

        const drops = [];
        for (let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -50;
        }

        function draw() {
            ctx.fillStyle = "rgba(0, 0, 0, 0.03)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#00ff41";
            ctx.font = fontSize + "px monospace";

            for (let i = 0; i < drops.length; i++) {
                const char =
                    charArray[Math.floor(Math.random() * charArray.length)];
                const x = i * fontSize * 3;
                const y = drops[i] * fontSize;

                if (Math.random() > 0.98) {
                    ctx.fillStyle = "#ffffff";
                } else {
                    ctx.fillStyle = "#00ff41";
                }

                ctx.fillText(char, x, y);

                if (y > canvas.height && Math.random() > 0.99) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }

        setInterval(draw, 100);

        window.addEventListener("resize", function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // ========== Reading Progress Bar ==========
        const progressBar = document.getElementById("reading-progress");
        if (progressBar) {
            window.addEventListener("scroll", function () {
                const scrollTop = window.scrollY;
                const docHeight =
                    document.documentElement.scrollHeight - window.innerHeight;
                const progress = (scrollTop / docHeight) * 100;
                progressBar.style.width = progress + "%";
            });
        }

        // ========== TOC Current Section Highlight ==========
        const tocLinks = document.querySelectorAll(".toc a");
        const headings = document.querySelectorAll(
            ".post-content h2, .post-content h3",
        );

        if (tocLinks.length > 0 && headings.length > 0) {
            window.addEventListener("scroll", function () {
                let current = "";
                headings.forEach(function (heading) {
                    const top = heading.getBoundingClientRect().top;
                    if (top < 150) {
                        current = heading.id;
                    }
                });

                tocLinks.forEach(function (link) {
                    link.classList.remove("active");
                    if (link.getAttribute("href") === "#" + current) {
                        link.classList.add("active");
                    }
                });
            });
        }

        // ========== Code Editor Effect for Homepage ==========
        const homeInfo = document.querySelector(".home-info .entry-content");
        if (homeInfo) {
            homeInfo.style.display = "none";
            const editorContainer = document.createElement("div");
            editorContainer.className = "code-editor";
            homeInfo.parentNode.insertBefore(editorContainer, homeInfo);

            editorContainer.innerHTML = `
                <div class="editor-header">
                    <div class="editor-dots">
                        <span class="dot red"></span>
                        <span class="dot yellow"></span>
                        <span class="dot green"></span>
                    </div>
                    <div class="editor-title">main.rs â€” ç¨‹åºå‘˜æ—¥è®°</div>
                </div>
                <div class="editor-body">
                    <div class="line-numbers"></div>
                    <div class="code-area">
                        <div class="code-content"></div>
                    </div>
                </div>
            `;

            const lineNumbers = editorContainer.querySelector(".line-numbers");
            const codeContent = editorContainer.querySelector(".code-content");
            const maxVisibleLines = 13;

            // ç¼–ç åŠ¨ä½œåºåˆ—ï¼šæ¨¡æ‹ŸçœŸå®ç¼–ç¨‹ä¹ æƒ¯
            // t=type, p=pause, d=dedent(å‡å°‘ç¼©è¿›)
            const actions = [
                // use è¯­å¥
                {t: "use anyhow::{Context, Result};\n"},
                {t: "use serde::{Deserialize, Serialize};\n"},
                {t: "use std::collections::HashMap;\n"},
                {t: "use tokio::time::{sleep, Duration};\n"}, {p: 100},
                {t: "\n"},

                // å¸¸é‡
                {t: "const VERSION: &str = \"0.1.0\";\n"}, {p: 80},
                {t: "\n"},

                // Post ç»“æ„ä½“
                {t: "/// åšå®¢æ–‡ç« \n"},
                {t: "#[derive(Debug, Clone, Serialize, Deserialize)]\n"},
                {t: "pub struct Post {\n"},
                {t: "id: u64,\n"},
                {t: "title: String,\n"},
                {t: "content: String,\n"},
                {t: "tags: Vec<String>,\n"},
                {t: "published: bool,\n"},
                {d: 1}, {t: "}\n"}, {p: 100},
                {t: "\n"},

                // Blog ç»“æ„ä½“
                {t: "/// ç¨‹åºå‘˜æ—¥è®° - æŠ€æœ¯åšå®¢ç³»ç»Ÿ\n"},
                {t: "#[derive(Debug, Clone)]\n"},
                {t: "pub struct Blog {\n"},
                {t: "name: String,\n"},
                {t: "author: String,\n"},
                {t: "posts: HashMap<u64, Post>,\n"},
                {t: "next_id: u64,\n"},
                {d: 1}, {t: "}\n"}, {p: 100},
                {t: "\n"},

                // impl Blog
                {t: "impl Blog {\n"},

                // new å‡½æ•°
                {t: "/// åˆ›å»ºæ–°çš„åšå®¢å®ä¾‹\n"},
                {t: "pub fn new(name: &str, author: &str) -> Self {\n"},
                {t: "Self {\n"},
                {t: "name: name.to_string(),\n"},
                {t: "author: author.to_string(),\n"},
                {t: "posts: HashMap::new(),\n"},
                {t: "next_id: 1,\n"},
                {d: 1}, {t: "}\n"},
                {d: 1}, {t: "}\n"}, {p: 80},
                {t: "\n"},

                // add_post å‡½æ•°
                {t: "/// æ·»åŠ æ–°æ–‡ç« \n"},
                {t: "pub fn add_post(&mut self, title: &str, content: &str) -> u64 {\n"},
                {t: "let id = self.next_id;\n"},
                {t: "let post = Post {\n"},
                {t: "id,\n"},
                {t: "title: title.to_string(),\n"},
                {t: "content: content.to_string(),\n"},
                {t: "tags: vec![],\n"},
                {t: "published: false,\n"},
                {d: 1}, {t: "};\n"},
                {t: "self.posts.insert(id, post);\n"},
                {t: "self.next_id += 1;\n"},
                {t: "id\n"},
                {d: 1}, {t: "}\n"}, {p: 80},
                {t: "\n"},

                // publish å‡½æ•°
                {t: "/// å‘å¸ƒæ–‡ç« \n"},
                {t: "pub fn publish(&mut self, id: u64) -> Result<()> {\n"},
                {t: "let post = self.posts.get_mut(&id)\n"},
                {t: "    .context(\"Post not found\")?;\n"},
                {t: "post.published = true;\n"},
                {t: "Ok(())\n"},
                {d: 1}, {t: "}\n"}, {p: 80},
                {t: "\n"},

                // run å‡½æ•°
                {t: "/// è¿è¡Œåšå®¢æœåŠ¡\n"},
                {t: "pub async fn run(&self) -> Result<()> {\n"},
                {t: 'println!("ğŸš€ {} v{}", self.name, VERSION);\n'},
                {t: 'println!("ğŸ‘¤ Author: {}", self.author);\n'},
                {t: 'println!("ğŸ“ Posts: {}", self.posts.len());\n'},
                {t: "\n"},
                {t: "loop {\n"},
                {t: "self.think().await;\n"},
                {t: "self.code().await;\n"},
                {t: "self.write().await;\n"},
                {t: "self.learn().await;\n"},
                {t: "sleep(Duration::from_secs(1)).await;\n"},
                {d: 1}, {t: "}\n"},
                {d: 1}, {t: "}\n"}, {p: 80},
                {t: "\n"},

                // ç§æœ‰æ–¹æ³•
                {t: "async fn think(&self) {\n"},
                {t: 'println!("ğŸ’­ Thinking...");\n'},
                {d: 1}, {t: "}\n"},
                {t: "\n"},

                {t: "async fn code(&self) {\n"},
                {t: 'println!("âŒ¨ï¸  Coding...");\n'},
                {d: 1}, {t: "}\n"},
                {t: "\n"},

                {t: "async fn write(&self) {\n"},
                {t: 'println!("âœï¸  Writing...");\n'},
                {d: 1}, {t: "}\n"},
                {t: "\n"},

                {t: "async fn learn(&self) {\n"},
                {t: 'println!("ğŸ“š Learning...");\n'},
                {d: 1}, {t: "}\n"},

                {d: 1}, {t: "}\n"}, {p: 120},
                {t: "\n"},

                // main å‡½æ•°
                {t: "#[tokio::main]\n"},
                {t: "async fn main() -> Result<()> {\n"},
                {t: 'let mut blog = Blog::new("ç¨‹åºå‘˜æ—¥è®°", "Zhangsan");\n'},
                {t: "\n"},
                {t: "// æ·»åŠ æ–‡ç« \n"},
                {t: 'let id = blog.add_post(\n'},
                {t: '    "Rust å¼‚æ­¥ç¼–ç¨‹å…¥é—¨",\n'},
                {t: '    "æœ¬æ–‡ä»‹ç» async/await çš„åŸºæœ¬ç”¨æ³•...",\n'},
                {t: ");\n"},
                {t: "blog.publish(id)?;\n"},
                {t: "\n"},
                {t: "// å¯åŠ¨æœåŠ¡\n"},
                {t: "blog.run().await\n"},
                {d: 1}, {t: "}\n"}, {p: 200},
            ];

            let lines = [""];
            let cursorLine = 0;
            let cursorCol = 0;
            let actionIndex = 0;

            function escapeHtml(str) {
                return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }

            function highlightLine(line) {
                const escaped = escapeHtml(line);
                const trimmed = escaped.trim();

                // æ³¨é‡Šè¡Œ
                if (trimmed.startsWith("///") || trimmed.startsWith("//")) {
                    return '<span class="cm">' + escaped + '</span>';
                }

                // å±æ€§å®è¡Œ
                if (trimmed.startsWith("#[")) {
                    return escaped.replace(/(#\[[^\]]+\])/, '<span class="at">$1</span>');
                }

                // æ™®é€šä»£ç è¡Œ
                let r = escaped;
                // å­—ç¬¦ä¸²
                r = r.replace(/"([^"]*)"/g, '<span class="st">"$1"</span>');
                // å…³é”®å­—
                r = r.replace(/\b(use|pub|struct|impl|fn|let|mut|async|await|loop|Self|self|for|in|if|else|match|return|mod|crate|super|where|trait|type|const|static|move|ref|dyn)\b/g, '<span class="kw">$1</span>');
                // ç±»å‹
                r = r.replace(/\b(String|Vec|Result|Option|Duration|Post|Blog|Ok|Err|Some|None)\b/g, '<span class="ty">$1</span>');
                // å®
                r = r.replace(/\b(println|vec|format|panic|assert|debug|tokio)!/g, '<span class="mc">$1!</span>');
                // æ•°å­—
                r = r.replace(/\b(\d+)\b/g, '<span class="num">$1</span>');
                return r;
            }

            function render() {
                const totalLines = lines.length;
                // ä»ç¬¬ä¸€è¡Œå¼€å§‹æ˜¾ç¤ºï¼Œå½“è¶…å‡ºæ—¶æ‰æ»šåŠ¨
                const startLine = Math.max(0, cursorLine - maxVisibleLines + 1);
                const endLine = Math.min(totalLines, startLine + maxVisibleLines);
                const visibleLines = lines.slice(startLine, endLine);

                let lineNums = "";
                for (let i = startLine; i < endLine; i++) {
                    lineNums += (i + 1) + "\n";
                }
                lineNumbers.textContent = lineNums;

                // æ¸²æŸ“ä»£ç ï¼Œåœ¨å…‰æ ‡ä½ç½®æ’å…¥å…‰æ ‡
                let html = "";
                for (let i = 0; i < visibleLines.length; i++) {
                    const actualLine = startLine + i;
                    let lineContent = visibleLines[i];

                    if (actualLine === cursorLine) {
                        // åœ¨å…‰æ ‡ä½ç½®æ’å…¥å…‰æ ‡
                        const before = lineContent.substring(0, cursorCol);
                        const after = lineContent.substring(cursorCol);
                        html += highlightLine(before) + '<span class="cursor"></span>' + highlightLine(after);
                    } else {
                        html += highlightLine(lineContent);
                    }
                    if (i < visibleLines.length - 1) html += "\n";
                }
                codeContent.innerHTML = html;
            }

            function insertChar(char) {
                if (char === "\n") {
                    const currentLine = lines[cursorLine];
                    const before = currentLine.substring(0, cursorCol);
                    const after = currentLine.substring(cursorCol);

                    // è®¡ç®—å½“å‰è¡Œçš„ç¼©è¿›
                    const indentMatch = before.match(/^(\s*)/);
                    const currentIndent = indentMatch ? indentMatch[1] : "";

                    // å¦‚æœè¡Œå°¾æ˜¯ {ï¼Œå¢åŠ ä¸€çº§ç¼©è¿›
                    const trimmedBefore = before.trimEnd();
                    let newIndent = currentIndent;
                    if (trimmedBefore.endsWith("{")) {
                        newIndent = currentIndent + "    ";
                    }

                    lines[cursorLine] = before;
                    lines.splice(cursorLine + 1, 0, newIndent + after);
                    cursorLine++;
                    cursorCol = newIndent.length;
                } else {
                    const currentLine = lines[cursorLine];
                    lines[cursorLine] = currentLine.substring(0, cursorCol) + char + currentLine.substring(cursorCol);
                    cursorCol++;
                }
            }

            function backspace() {
                if (cursorCol > 0) {
                    const currentLine = lines[cursorLine];
                    lines[cursorLine] = currentLine.substring(0, cursorCol - 1) + currentLine.substring(cursorCol);
                    cursorCol--;
                } else if (cursorLine > 0) {
                    const currentLine = lines[cursorLine];
                    const prevLine = lines[cursorLine - 1];
                    cursorCol = prevLine.length;
                    lines[cursorLine - 1] = prevLine + currentLine;
                    lines.splice(cursorLine, 1);
                    cursorLine--;
                }
            }

            function getTypeDelay() {
                return 25 + Math.random() * 25;
            }

            function processAction() {
                if (actionIndex >= actions.length) {
                    setTimeout(() => {
                        lines = [""];
                        cursorLine = 0;
                        cursorCol = 0;
                        actionIndex = 0;
                        render();
                        setTimeout(processAction, 800);
                    }, 2500);
                    return;
                }

                const action = actions[actionIndex];
                actionIndex++;

                if (action.t !== undefined) {
                    // æ‰“å­—
                    const text = action.t;
                    let i = 0;
                    function typeNext() {
                        if (i < text.length) {
                            // æ£€æµ‹è¡Œé¦–ç¼©è¿›ï¼ˆ4ä¸ªç©ºæ ¼ = 1ä¸ªTabï¼‰
                            if (text.substr(i, 4) === "    " && cursorCol % 4 === 0) {
                                // ä¸€æ¬¡æ’å…¥4ä¸ªç©ºæ ¼ï¼Œæ¨¡æ‹ŸTab
                                for (let j = 0; j < 4; j++) {
                                    insertChar(" ");
                                }
                                render();
                                i += 4;
                                setTimeout(typeNext, 60 + Math.random() * 40);
                                return;
                            }

                            const char = text[i];

                            // å¶å°”æ‰“é”™
                            if (Math.random() < 0.02 && /[a-z]/i.test(char)) {
                                const wrong = String.fromCharCode(char.charCodeAt(0) + (Math.random() > 0.5 ? 1 : -1));
                                insertChar(wrong);
                                render();
                                setTimeout(() => {
                                    backspace();
                                    render();
                                    setTimeout(() => {
                                        insertChar(char);
                                        render();
                                        i++;
                                        setTimeout(typeNext, getTypeDelay());
                                    }, 60);
                                }, 100);
                                return;
                            }

                            insertChar(char);
                            render();
                            i++;
                            let delay = getTypeDelay();
                            if (char === "\n") delay = 60 + Math.random() * 40;
                            setTimeout(typeNext, delay);
                        } else {
                            setTimeout(processAction, 30);
                        }
                    }
                    typeNext();
                } else if (action.d !== undefined) {
                    // å‡å°‘ç¼©è¿›ï¼ˆåˆ é™¤è¡Œé¦–çš„4ä¸ªç©ºæ ¼ï¼‰
                    const currentLine = lines[cursorLine];
                    if (currentLine.startsWith("    ")) {
                        lines[cursorLine] = currentLine.substring(4);
                        cursorCol = Math.max(0, cursorCol - 4);
                    }
                    render();
                    setTimeout(processAction, 150 + Math.random() * 100);
                } else if (action.p !== undefined) {
                    // æš‚åœæ€è€ƒ
                    setTimeout(processAction, action.p + Math.random() * 100);
                }
            }

            render();
            setTimeout(processAction, 600);
        }

        // ========== Add Language Labels to Code Blocks ==========
        document.querySelectorAll(".highlight").forEach(function (block) {
            const pre = block.querySelector("pre");
            if (pre) {
                const classes = block.className.split(" ");
                let lang = "";
                classes.forEach(function (cls) {
                    if (cls.startsWith("language-")) {
                        lang = cls.replace("language-", "");
                    }
                });
                if (!lang) {
                    const codeEl = pre.querySelector("code");
                    if (codeEl) {
                        const codeClasses = codeEl.className.split(" ");
                        codeClasses.forEach(function (cls) {
                            if (cls.startsWith("language-")) {
                                lang = cls.replace("language-", "");
                            }
                        });
                    }
                }
                if (lang) {
                    pre.setAttribute("data-lang", lang);
                }
            }
        });

        // ========== External Link Icons ==========
        document.querySelectorAll(".post-content a").forEach(function (link) {
            const href = link.getAttribute("href");
            if (
                href &&
                href.startsWith("http") &&
                !href.includes(window.location.hostname)
            ) {
                link.classList.add("external-link");
                link.setAttribute("target", "_blank");
                link.setAttribute("rel", "noopener noreferrer");
            }
        });
    });
</script>
