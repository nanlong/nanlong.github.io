---
title: "密码安全进化史（三）：SRP，证明你知道密码却不说出密码"
date: 2025-12-05T12:00:00+08:00
draft: false
tags: ["密码安全", "SRP", "零知识证明", "安全"]
categories: ["技术"]
description: "你能向别人证明你知道一个秘密，但完全不用透露这个秘密本身。这就是 SRP 协议的魔力。"
series: ["密码安全进化史"]
cover:
  image: "/images/posts/password-evolution-3-srp.svg"
  alt: "SRP - Secure Handshake"
  relative: false
---

## 前情回顾

在前两篇中，我们看到了密码存储的进化：
- **MD5**：太快，彩虹表秒破
- **Argon2**：慢哈希 + 吃内存，大幅提高破解成本

但即使用了 Argon2，有一个根本问题没解决：**密码仍然要传到服务器上**。

服务器会"看到"你的密码，哪怕只是短暂的一瞬间。如果服务器被黑客控制、如果有恶意管理员、如果内存被 dump……密码仍可能泄露。

有没有办法让服务器**永远不知道**你的密码，却仍能验证你的身份？

答案是：**SRP 协议**。

## 从一个问题说起

每次你在网站上输入密码登录时，发生了什么？

```text
传统方式：
你 → 输入密码 → 网站收到密码 → 验证 → 登录成功
```

这个过程有一个根本性的问题：**你的密码被发送到了网站服务器**。

这意味着：
- 如果网络被监听，密码可能泄露
- 如果网站被黑客攻破，密码可能泄露
- 如果网站管理员是坏人，他能看到你的密码
- 如果你在多个网站用同一个密码（别装了，很多人都这样），一个网站泄露 = 全部泄露

## 一个生活中的类比

想象特工电影里的"对暗号"场景。

**传统对暗号**：
> 甲："天王盖地虎"
> 乙："宝塔镇河妖"

问题：暗号直接说出口，被窃听就泄露了。

**SRP 风格的对暗号**：

首先，**注册阶段**（你和总部建立联系）：
> 你的密码是"玫瑰"
> 你用"玫瑰"生成一个数学规则，告诉总部
> 总部存储这个"规则"，但不知道你的密码是"玫瑰"

然后，**验证阶段**（每次接头）：
```text
You                                 HQ
 |                                   |
 |  1. I say a random number: 37     |
 |  -------------------------------> |
 |                                   |
 |  2. HQ says random number: 82     |
 |  <------------------------------- |
 |                                   |
 |  3. I compute with pwd+37+82      |
 |     -> result: 9527               |  3. HQ computes with rule+37+82
 |                                   |
 |  4. Send 9527 over                |
 |  -------------------------------> |
 |                                   |  4. HQ also gets 9527!
 |                                   |     Identity confirmed!
```

**为什么这样更安全？**

窃听者听到了什么？
- 随机数 37 和 82
- 结果 9527

窃听者能推出密码吗？**不能！**
- 37、82、9527 之间的数学关系极其复杂
- 而且下次的随机数完全不同，9527 也没法重放

**这就是 SRP 的核心思想：双方各自计算，如果密码正确，结果相同。密码本身从未传输。**

## SRP 是什么？

SRP（Secure Remote Password，安全远程密码）是 1998 年由斯坦福大学的 Tom Wu 发明的协议。它让你能够：

1. **证明你知道密码**，但密码永远不离开你的设备
2. **服务器验证你的身份**，但服务器从不知道你的真实密码
3. **建立加密通道**，后续通信完全加密

## SRP 的工作原理（简化版）

### 第一步：注册（只发生一次）

当你在网站注册账号时：

```text
你的设备上发生的事情：
密码 "mypassword123"
    ↓ 加入一些随机"盐"
    ↓ 进行数学运算
    ↓
生成一个"验证器"（一个很大的数字）

发送给服务器：
- 用户名
- 随机"盐"
- "验证器"

❌ 不发送：密码本身
```

**关键点**：服务器只存储"验证器"。这个验证器是通过密码计算出来的，但**无法反向推出密码**（就像知道鸡蛋饼的样子，无法还原出鸡蛋）。

### 第二步：登录（每次都这样）

登录过程像一场精心设计的"数学对话"：

```text
+--------+                                      +--------+
|  You   |                                      | Server |
+--------+                                      +--------+
    |                                               |
    |  "I'm Alice, here's my temp number A"         |
    |  -------------------------------------------> |
    |                                               |
    |  "OK Alice, here's your salt and my temp B"   |
    |  <------------------------------------------- |
    |                                               |
    |  [Both sides do complex math calculations]    |
    |  [If password correct, both get same key]     |
    |                                               |
    |  "Here's my proof M1"                         |
    |  -------------------------------------------> |
    |                                               |  Verify M1
    |  "Verified! Here's my proof M2"               |
    |  <------------------------------------------- |
    |  Verify M2                                    |
    |                                               |
    |  [Both confirmed, encrypted channel ready]    |
```

**整个过程中，密码始终没有离开你的设备！**

## 为什么 SRP 是安全的？

让我们看看各种攻击者能得到什么：

### 场景 1：黑客监听网络

```text
黑客看到的：
- 用户名：张三
- 数字 A：984729847298...
- 数字 B：293847293847...
- 证明 M1：182736481726...
- 证明 M2：918273648172...

黑客能推出密码吗？❌ 不能！
这些数字之间的数学关系极其复杂，
而且每次登录 A 和 B 都是随机的。
```

### 场景 2：黑客攻破了服务器数据库

```text
黑客得到的：
- 用户名：张三
- 盐：x8k2m...
- 验证器：2938472938...

黑客能用这些登录吗？❌ 不能！
验证器无法直接用于登录，
登录需要密码来计算正确的数学响应。

黑客能反推出密码吗？❌ 极其困难！
这需要暴力破解，而且每个用户的盐不同，
无法批量破解。
```

### 场景 3：黑客同时监听网络 + 攻破数据库

```text
即使两者结合：❌ 仍然无法得到密码！
SRP 的数学设计保证了这一点。
```

## SRP vs 传统密码方案

| 对比项 | 传统方案 | SRP |
|-------|---------|-----|
| 密码是否传输 | ✅ 是，每次登录都传 | ❌ 从不传输 |
| 服务器知道密码吗 | ✅ 知道（或其哈希） | ❌ 永远不知道 |
| 网络监听能偷到密码吗 | ✅ 可能（依赖 HTTPS） | ❌ 不可能 |
| 数据库泄露能直接登录吗 | ⚠️ 可能（如果哈希被破解） | ❌ 不可能 |
| 需要依赖 HTTPS 吗 | ✅ 强依赖 | ⚠️ 建议用，但不依赖 |

## SRP 的实际应用

SRP 已经在很多地方被使用：

- **苹果 iCloud**：保护你的 Apple ID
- **1Password**：知名密码管理器
- **ProtonMail**：加密邮件服务
- **很多企业内部系统**：金融、医疗等高安全场景

## SRP 的局限性

虽然 SRP 很强大，但它不是万能的：

1. **实现复杂**：比普通密码系统复杂得多，容易实现出错
2. **不能防止弱密码**：如果你的密码是"123456"，暴力破解仍然容易
3. **需要客户端配合**：浏览器/App 必须实现 SRP 逻辑
4. **有更新的替代方案**：OPAQUE 协议提供了更强的安全保证

## 技术细节（给好奇的读者）

SRP 的数学基础是**离散对数问题**，简单说就是：

```text
已知：g, N, 和 v = g^x mod N
求：x

这在数学上是极其困难的（已知的最好算法需要天文数字级的计算量）
```

注册时：
```text
x = hash(盐, 密码)
v = g^x mod N    ← 这个 v 就是"验证器"
```

登录时的数学交换确保：
- 只有知道 x（即知道密码）的人才能计算出正确的会话密钥
- 窃听者无法从 A、B、M1、M2 反推出 x
- 服务器无法从 v 反推出 x

## 总结

SRP 协议实现了一个看似不可能的目标：**让你证明你知道密码，而不用透露密码本身**。

它就像一个精心设计的数学魔术：
- 你和服务器进行一场"数学对话"
- 如果你知道正确的密码，对话会成功
- 任何旁观者都无法从对话中得到有用信息
- 服务器从始至终不知道你的密码是什么

这就是现代密码学的魅力——用数学的力量，保护我们的数字生活。

---

但 SRP 还有一个隐藏的弱点：服务器存储的"验证器"仍然与密码相关。如果数据库泄露，攻击者仍可以离线暴力破解。

有没有办法让数据库泄露也无法离线破解？下一篇我们介绍 **OPAQUE 协议**——它把暴力破解从"离线"逼到"在线"。

---

*上一篇：[Argon2：慢哈希的艺术](/posts/password-evolution-2-argon2/)*
*下一篇：[OPAQUE：防离线破解的终极方案](/posts/password-evolution-4-opaque/)*

*本系列：*
1. *[MD5：一部血泪史](/posts/password-evolution-1-md5/)*
2. *[Argon2：慢哈希的艺术](/posts/password-evolution-2-argon2/)*
3. *SRP：证明你知道密码却不说出密码（本篇）*
4. *[OPAQUE：防离线破解的终极方案](/posts/password-evolution-4-opaque/)*

*延伸阅读：零知识证明、Diffie-Hellman 密钥交换*
