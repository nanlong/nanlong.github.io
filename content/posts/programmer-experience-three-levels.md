---
title: "学编程，我们到底要积累什么经验？"
date: 2025-12-18T10:00:00+08:00
draft: true
tags: ["职业成长", "编程思维", "软件工程", "技术认知"]
categories: ["技术"]
description: "「要求 5 年工作经验」——但什么是真正的经验？10 年经验可能只是 1 年经验重复了 10 次。经验不是年限的堆砌，而是认知的跃迁。"
---

「要求 5 年工作经验」——但什么是真正的经验？10 年经验可能只是 1 年经验重复了 10 次。经验不是年限的堆砌，而是认知的跃迁。

<!--more-->

## 一个尴尬的招聘现场

「招聘：高级后端工程师，要求 5 年以上工作经验。」

打开任何一个招聘网站，你会发现「X 年经验」几乎是所有技术岗位的标配。仿佛经验是可以用年份称重的商品——3 年是初级，5 年是中级，8 年是高级。

但真的是这样吗？

候选人 A，8 年工作经验。面试时，各种技术名词信手拈来：微服务、DDD、分布式事务、最终一致性……简历上的项目经历整整两页。但当面试官问「你们为什么选择微服务架构」时，他愣住了。

「因为……大家都在用？」

候选人 B，只有 3 年经验。他没有用过微服务，但他能清晰地解释：为什么在他的场景下选择了单体架构，什么时候会考虑拆分，拆分时会面临哪些挑战，以及他从一次失败的过早拆分中学到了什么。

**最终，B 拿到了 offer。A 没有。**

这个场景揭示了一个残酷的事实：**年限 ≠ 经验。**

8 年里重复着差不多的 CRUD，和 3 年里不断挑战边界、反思总结，积累的「经验」根本不是同一种东西。

**那么问题来了：真正的经验，到底是什么？**

## 经验的三个层次

我把程序员的经验分为三个层次：

| 层次 | 特征 |
|------|------|
| **第一层：会做** | 能完成任务，但不知道为什么 |
| **第二层：知道为什么** | 理解原理，能解释每个决策 |
| **第三层：知道何时用** | 看到问题就知道用什么方案 |

大多数程序员，哪怕工作了 10 年，可能还停留在第一层。

**这不是能力问题，是学习方法问题。**

## 第一层：会做

在这一层，你能完成工作，但严重依赖：

- 教程、文档、Stack Overflow
- 复制粘贴现有代码
- 别人搭好的脚手架

第一层的典型特征是「换个环境就懵」。用 React 能写页面，换成 Vue 就不会了。在公司项目里得心应手，自己从零搭项目就无从下手。

让我们看看程序员需要积累的七个核心技能，在第一层是什么样子：

### 编程语言

会写语法正确的代码，但经常写出「能跑但不对」的程序：

```rust
fn get_user(id: i32) -> User {
    let user = db.query(&format!("SELECT * FROM users WHERE id = {}", id));
    user.unwrap()
}
```

字符串拼接 SQL（SQL 注入风险）、直接 `unwrap()`（程序随时可能崩溃）——但它能跑，所以「没问题」。

换一门语言，需要从头学起，因为只记住了语法，没有理解语言设计背后的思想。

### 语言生态

知道有哪些流行的库，但不知道为什么选它。「用 Tokio 是因为大家都用」「用 Express 是因为 Star 最多」。遇到库的边界情况就束手无策。

### 数据库

会写基本的 CRUD。查询慢了就加索引，加了索引还慢就加机器。不理解为什么有时候索引反而让查询变慢。

### 算法与数据结构

刷过 LeetCode，面试时能写出来。但工作中遇到性能问题，想不到用什么数据结构来优化。

### 设计模式

能背出 23 种设计模式的名字和 UML 图。但写代码时脑子里想的是「这里该用什么模式」，而不是「这里有什么问题需要解决」。

### 架构能力

知道分层、MVC、微服务这些词。但问「为什么要分层」「什么时候该拆微服务」，答不上来。

### 领域知识

能实现产品经理提出的需求。但从不质疑需求是否合理，也不会主动提出更好的方案。

---

**第一层不是羞耻。** 每个人都从第一层开始。问题在于：**很多人在第一层停了太久。**

每天重复着差不多的工作，用同样的方式解决同样的问题。一年、两年、五年……工资涨了，Title 升了，但能力原地踏步。

这就是「1 年经验重复 N 次」的真相。

## 第二层：知道为什么

从第一层到第二层的跃迁，只需要养成一个习惯：

> **对每一行代码、每一个选择，问一句「为什么」。**

第二层的程序员能解释自己代码的每一个决策：

```rust
fn get_user(id: i32) -> Result<User, DbError> {
    db.query("SELECT * FROM users WHERE id = $1", &[&id])
}
```

同样是查询用户，但每一处都有理由：参数化查询防止 SQL 注入；返回 `Result` 让调用方决定如何处理错误，比 `unwrap()` 更灵活，也更安全。

让我们看看七个核心技能在第二层的表现：

### 编程语言

理解语言的设计哲学，能回答这些问题：

- **Rust 为什么要有所有权系统？** 为了在编译期保证内存安全，同时实现零运行时开销。
- **Go 早期为什么没有泛型？** 设计者优先考虑简单性和快速编译。1.18 加入泛型是权衡后的演进。
- **JavaScript 为什么是单线程 + 事件循环？** Brendan Eich 用 10 天创造了它，单线程是当时最简单的选择；事件循环让单线程也能处理异步 I/O。

学新语言时，关注的不是语法差异，而是「这门语言用什么方式解决什么问题」。从 Java 转 Rust，你会思考：

- Java 用 GC 管理内存，Rust 用所有权——GC 降低心智负担但占用运行时资源，所有权学习曲线陡峭但零运行时开销。
- Java 用异常处理错误，Rust 用 Result——异常让正常流程更清晰，Result 强制处理每个可能的失败。
- Java 有继承，Rust 只有组合——继承可能导致脆弱的层级结构，组合更灵活但需要更多显式代码。

### 语言生态

知道每个主流库的定位和取舍：

| 需求 | 选择 | 原因 |
|------|------|------|
| Web 框架 | Actix vs Axum | Actix 性能极致但学习曲线陡峭，Axum 更符合 Rust 惯用法 |
| 异步运行时 | Tokio vs async-std | Tokio 生态成熟，async-std 更轻量 |
| 序列化 | Serde | 几乎没有第二选择，因为太强了 |

更重要的是，你知道什么时候**不用**第三方库。简单的任务，标准库就够了。

### 数据库

理解数据库的工作原理：

- B+ 树索引为什么适合范围查询？
- 为什么有时候全表扫描比索引更快？
- 什么情况下应该反范式化？
- 乐观锁和悲观锁各自适合什么场景？

你不再盲目「加索引」，而是先用 EXPLAIN 分析查询计划，找到真正的瓶颈。

### 算法与数据结构

在工作中能识别算法场景：

- 「这个排行榜需要频繁插入和查询 Top K」→ 堆
- 「这个布隆过滤器可以减少 90% 的数据库查询」→ 空间换时间
- 「这个限流器用令牌桶比固定窗口更平滑」→ 场景匹配

你不再把算法当成面试题，而是解决问题的工具。

### 设计模式

理解模式背后的原则，而不是模式本身：

- 单例模式的本质是「全局唯一性」，在 Rust 里用 `OnceLock` 实现
- 策略模式的本质是「行为可替换」，在 Rust 里用 trait 实现
- 观察者模式的本质是「解耦通知」，在 Rust 里用 channel 实现

你不再问「这里该用什么模式」，而是问「这里有什么问题需要解决」。

### 架构能力

理解每种架构的适用场景：

- **分层架构**：业务逻辑和技术细节分离，便于测试和维护
- **DDD**：复杂业务领域，需要和领域专家紧密协作
- **微服务**：团队规模大、部署频率高、需要独立扩展

你不会因为「大厂都在用」就上微服务，也不会因为「架构师说的」就盲目分层。

### 领域知识

能和产品经理、业务专家对话。不只是实现需求，还能质疑需求：

> 「这个审批流程为什么要串行？并行审批会不会更高效？」
> 「这个库存模型没有考虑预售场景，会不会导致超卖？」

你开始用领域语言思考，而不只是用技术语言。

---

第二层的程序员是团队的中坚力量。他们写的代码靠谱，做的设计有理有据。

但第二层有一个局限：**他们知道「怎么做对」，但不知道「什么时候做什么」。**

面对新问题，他们需要分析、讨论、权衡。这没有错，但还不够快。

真正的高手，是在第三层。

## 第三层：知道何时用

第三层的特征是**直觉**。

不是玄学的直觉，而是经过大量「第二层式」思考后，内化成的快速判断。

就像国际象棋大师看到棋盘，不需要逐步分析，就能感觉到最佳走法。这不是天赋，是他们见过几万盘棋之后，模式识别能力的涌现。

第三层的程序员看到一个问题，脑子里会自动跳出：

> 「这个场景我见过，用 X 方案可以解决，但要注意 Y 陷阱。」

让我们看看七个核心技能在第三层的表现：

### 编程语言

**语言是工具，问题决定工具。**

- 写高性能系统？Rust 或 C++
- 快速原型验证？Python 或 TypeScript
- 并发密集型？Go 或 Erlang/Elixir
- 数据处理？Python 或 Julia

你不会陷入「语言圣战」，因为你知道每种语言都有自己的最佳战场。

更重要的是，你能在一门语言中「带入」其他语言的最佳实践。用 Rust 写代码时，你会想到 Haskell 的类型系统思想；用 Go 写并发时，你理解它背后的 CSP 模型，也能对比 Erlang 的 Actor 模型——两者都是「通过通信共享内存」，但实现哲学不同。

### 语言生态

**不是选最流行的，而是选最合适的。**

你知道什么时候用成熟的框架，什么时候自己造轮子。你能预判一个库的未来——它会成为标准，还是昙花一现。

你有自己的「技术雷达」：哪些技术值得跟进，哪些只是炒作，哪些已经过时但在特定场景仍有价值。

### 数据库

**数据建模反映业务理解。**

你能在项目初期就预判数据增长模式，选择合适的数据库：

- 事务为主、关系复杂？PostgreSQL
- 读多写少、需要灵活 Schema？MongoDB
- 超高并发简单查询？Redis
- 时序数据？TimescaleDB 或 InfluxDB
- 需要全文搜索？Elasticsearch

你不迷信「一个数据库打天下」，也不过度设计「每种数据用一种库」。你知道 PostgreSQL 能 cover 80% 的场景，只有在真正需要时才引入专用数据库。

### 算法与数据结构

**算法直觉已经内化。**

你不需要刻意思考「这里用什么数据结构」，因为你已经见过太多类似场景：

- 「频繁插入删除，偶尔排序」→ 可能不需要有序数据结构，用数组+延迟排序更简单
- 「分布式环境下的唯一性判断」→ 布隆过滤器 + 精确检查
- 「实时统计 PV/UV」→ HyperLogLog

你知道什么时候「正确答案」其实不是最佳答案。面试时写的最优解，在工程中可能因为复杂度、可维护性而不是首选。

### 设计模式

**模式已经融入血液。**

你不再「使用」设计模式，而是「自然而然」地写出符合模式的代码。因为你理解的是原则，不是形式。

你甚至知道什么时候该「打破」模式。在简单场景硬套模式是过度设计，在复杂场景不用模式是能力不足。**边界在哪，是第三层的核心能力。**

### 架构能力

**架构决策是权衡，不是正确答案。**

你能快速评估：

- 这个系统的核心复杂度是什么？是业务逻辑复杂，还是技术挑战大？
- 团队规模和能力如何？高级架构需要高级团队来维护
- 时间和预算约束是什么？有时候「不完美但够用」才是最优解
- 未来 1-3 年会有什么变化？过度设计和欠缺设计一样有害

你不追求「理论上最好的架构」，而是追求「在约束下最合适的架构」。

### 领域知识

**你成为领域专家。**

在这个层次，你不只是「懂技术的人」，而是「懂业务的技术专家」。

你能用代码建模复杂的业务规则，能发现产品设计中的逻辑漏洞，能预判业务发展对技术的影响。

**最优秀的架构师，往往也是领域专家。**

---

当直觉内化到一定程度，第三层的程序员会自然地做一件事：**把思维方式传递给他人。**

不是教别人「怎么做」，而是传递「怎么思考」。他们做的技术决策、写的设计文档、code review 的评论，都在帮助团队提升判断力。

**这就是为什么第三层的程序员往往是团队的技术领袖——他们不只是自己强，还能让团队变强。**

---

第三层不是终点，而是一个不断扩展的领域。技术在变化，业务在变化，你永远有新的「第一层」要突破、新的「第二层」要深化。

**但到达第三层的人，已经掌握了「如何到达第三层」的方法论。** 这让他们能在任何新领域快速成长——因为他们学的不是知识，而是「如何学习知识」。

## 自我诊断清单

读到这里，你可能想知道：我在哪一层？

这里有一个简单的自我诊断清单。对于你主要使用的技术栈，问自己这些问题：

### 编程语言

- [ ] 我能不查文档写出中等复杂度的程序吗？（第一层门槛）
- [ ] 我能解释这门语言的核心设计决策吗？（第二层门槛）
- [ ] 我能判断什么问题适合用这门语言，什么不适合吗？（第三层门槛）

### 语言生态

- [ ] 我知道主流的库有哪些吗？（第一层门槛）
- [ ] 我能解释为什么选择 A 库而不是 B 库吗？（第二层门槛）
- [ ] 我能预判一个库是否值得投入学习吗？（第三层门槛）

### 数据库

- [ ] 我能写出正确的 SQL 和建立基本的索引吗？（第一层门槛）
- [ ] 我能解释查询计划并优化慢查询吗？（第二层门槛）
- [ ] 我能在项目初期选择合适的数据库和数据模型吗？（第三层门槛）

### 算法与数据结构

- [ ] 我能实现基本的排序和查找算法吗？（第一层门槛）
- [ ] 我能在工作中识别算法优化机会吗？（第二层门槛）
- [ ] 我能快速判断什么场景用什么数据结构最合适吗？（第三层门槛）

### 设计模式

- [ ] 我知道常见的设计模式吗？（第一层门槛）
- [ ] 我理解这些模式要解决什么问题吗？（第二层门槛）
- [ ] 我能自然地写出符合模式的代码，并知道何时该打破模式吗？（第三层门槛）

### 架构能力

- [ ] 我知道 MVC、分层、微服务这些概念吗？（第一层门槛）
- [ ] 我能解释每种架构的适用场景和权衡吗？（第二层门槛）
- [ ] 我能在给定约束下设计出合适的架构吗？（第三层门槛）

### 领域知识

- [ ] 我能准确实现产品需求吗？（第一层门槛）
- [ ] 我能用领域语言和业务人员沟通吗？（第二层门槛）
- [ ] 我能发现需求中的业务逻辑漏洞并提出更好的方案吗？（第三层门槛）

---

如果你发现大部分技能都在第一层，不要沮丧。知道自己在哪里，是进步的开始。

如果你发现某些技能在第二层甚至第三层，但另一些还在第一层，这很正常。没有人在所有领域都是专家。**关键是知道自己的优势和短板。**

## 如何跃迁

### 从第一层到第二层：问「为什么」

这是最关键的一跃，也是投入产出比最高的一跃。

方法很简单：**对每一件你「会做」的事，问「为什么」。**

- 为什么这个函数要返回 Result？
- 为什么这个查询要加索引？
- 为什么这个架构要分这几层？
- 为什么产品设计成这个样子？

如果你答不上来，就去找答案。读文档、读源码、问同事、搜索。

**每回答一个「为什么」，你就在第二层迈进一步。**

一个实用的练习是「代码考古」：找一个成熟的开源项目，追溯它的 Git 历史。看看它的架构是怎么演化的，每个重大决策是出于什么原因。你会发现，很多「最佳实践」都是踩过坑之后的总结。

### 从第二层到第三层：积累「决策案例」

第三层的「直觉」来自大量的「第二层式」思考。没有捷径，只有积累。

但你可以让积累更高效：

**1. 刻意记录决策**

每做一个技术决策，写下来：

- 问题是什么？
- 考虑了哪些方案？
- 最终选择了什么？为什么？
- 事后看，这个决策对不对？

这不是为了写文档，而是为了强迫自己思考。一年后回看这些记录，你会发现自己的判断力在提升。

**2. 主动扩展边界**

在舒适区里待着，不会成长。

主动接触新的问题类型、新的技术栈、新的业务领域。每次「不会」都是学习机会。

**3. 向高手学习**

找到你领域里的高手，观察他们怎么做决策。

- 他们关注什么信息？
- 他们的思考路径是什么？
- 他们怎么平衡各种约束？

如果可能，让他们 review 你的设计。高手的一句点拨，可能抵得上你自己摸索几个月。

**4. 复盘、复盘、复盘**

每个项目结束后，花时间复盘：

- 什么做得好？为什么？
- 什么做得不好？如果重来会怎么做？
- 有什么经验可以迁移到下一个项目？

**不复盘的经历，只是经历，不是经验。**

## 常见问题

### Q：是不是每个技能都要练到第三层？

**A：不是，也做不到。**

人的精力有限。合理的策略是：

- 你的核心技能（吃饭的本事）：争取到第三层
- 经常用到的技能：稳固在第二层
- 偶尔用到的技能：第一层够用了

比如，你是后端工程师，核心语言和架构设计应该追求第三层；前端技术第二层足够；设计、产品知识第一层也 OK。

### Q：感觉一直在第一层出不来怎么办？

**A：可能是学习方法的问题，也可能是工作环境的问题。**

学习方法的问题：你可能一直在「用」技术，而没有「学」技术。试着每周花 2 小时，不是做项目，而是读文档、读源码、理解原理。

工作环境的问题：如果你的工作只是重复性的 CRUD，没有挑战，你很难成长。考虑：
- 在工作中主动接手更复杂的任务
- 业余时间做有挑战的 side project
- 换一份能让你成长的工作

### Q：跳槽时怎么展示自己在哪一层？

**A：讲故事，不要罗列技能。**

第一层：「我用过 React、Vue、Angular……」（技能清单）

第二层：「我选择 React 是因为……在这个项目中，我遇到了 X 问题，通过 Y 方式解决了。」（有理有据的经历）

第三层：「这类系统我做过很多，通常会面临 A、B、C 三种选择，不同场景下我会……」（体系化的判断力）

## 写在最后

回顾整篇文章，有一个核心洞见值得深思：

**经验不是「做过什么」，而是「理解了什么」。**

做过不代表懂了。很多人写了 10 年 CRUD，对数据库的理解还停留在「加索引能变快」。

懂了也不代表会用。很多人能讲清 CAP 定理，但做系统设计时照样做出不合理的选择。

**真正的经验，是把「知道」转化为「判断力」的过程。**

这个转化需要时间，需要刻意练习，需要不断复盘。没有捷径，但有方法。

程序员这一行，变化快、新东西多，很容易陷入「追新」的焦虑。但如果你仔细观察会发现：**新技术层出不穷，底层的原则却惊人地稳定。**

所有权和借用是新概念吗？不是，只是 Rust 把它显式化了。
微服务是新架构吗？不是，只是 Unix 的「小工具组合」哲学在分布式时代的重现。
Actor 模型是新并发模型吗？不是，它比你我都老。

**积累经验，本质上是在积累「不变」的东西。**

当你理解了内存管理的本质，学 Rust 的所有权只是学一种新的表达方式。
当你理解了模块化和组合的原则，微服务只是这些原则在分布式环境下的应用。
当你理解了并发的本质问题，Actor、CSP、协程都只是不同的解决方案。

这就是为什么第三层的程序员学新东西特别快——他们不是在从零开始，而是在已有的知识体系上「挂」新知识。

所以，回到开头的问题：**学编程，我们到底要积累什么经验？**

答案是：积累那些不会过时的东西。

- 原理比语法重要。
- 判断力比技能重要。
- 「为什么」比「怎么做」重要。

**经验不是年限的堆砌，而是认知的跃迁。**

还记得开头那个拿到 offer 的候选人 B 吗？他只有 3 年经验，却比 8 年经验的 A 更有竞争力。区别在哪？

**他每做一件事，都会问自己「为什么」。**

从今天开始，你也可以。
