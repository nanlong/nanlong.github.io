---
title: "密码安全进化史（一）：从明文到 MD5，一部血泪史"
date: 2025-12-05T10:00:00+08:00
draft: false
tags: ["密码安全", "MD5", "哈希", "安全"]
categories: ["技术"]
description: "从最原始的密码存储方式讲起，看看早期网站是怎么保护你的密码的——以及为什么这些方法都失败了。"
series: ["密码安全进化史"]
cover:
  image: "/images/posts/password-evolution-1-md5.svg"
  alt: "MD5 - Deprecated"
  relative: false
---

## 石器时代：明文存储

在互联网的蛮荒年代，很多网站是这样存密码的：

```text
User Table:
+----------+----------+
| username | password |
+----------+----------+
| alice    | 123456   |
| bob      | password |
| charlie  | qwerty   |
+----------+----------+
```

是的，**直接把密码原样存进数据库**。

这有多可怕？

- 数据库管理员能看到所有人的密码
- 数据库被黑客攻破 = 所有密码直接泄露
- 备份文件泄露 = 所有密码直接泄露
- 打印一份报表 = 所有密码直接泄露

你可能觉得这是"古代"的事？2012 年，LinkedIn 泄露了 600 万用户数据，其中相当一部分是简单哈希甚至更弱的保护。2016 年，这个数字被更正为 **1.17 亿**。

## 青铜时代：MD5 登场

为了解决明文存储的问题，程序员们引入了"哈希函数"的概念。

### 什么是哈希？

哈希就像一台"绞肉机"：

```text
输入：一头完整的猪
      ↓ [绞肉机]
输出：一堆肉糜

特点：
✅ 同一头猪，总是产出相同的肉糜（确定性）
✅ 看着肉糜，无法还原出猪的样子（不可逆）
✅ 不同的猪，产出的肉糜不同（抗碰撞）
```

MD5 就是这样一台"数学绞肉机"：

```text
MD5("123456")     → "e10adc3949ba59abbe56e057f20f883e"
MD5("password")   → "5f4dcc3b5aa765d61d8327deb882cf99"
MD5("hello")      → "5d41402abc4b2a76b9719d911017c592"
```

### MD5 存储密码的方式

```text
注册时：
用户输入密码 "123456"
    ↓ MD5
存储 "e10adc3949ba59abbe56e057f20f883e"

登录时：
用户输入密码 "123456"
    ↓ MD5
计算出 "e10adc3949ba59abbe56e057f20f883e"
    ↓
与数据库存储的值比对 → 相同 → 登录成功！
```

数据库现在长这样：

```text
User Table:
+----------+----------------------------------+
| username | password_hash                    |
+----------+----------------------------------+
| alice    | e10adc3949ba59abbe56e057f20f883e |
| bob      | 5f4dcc3b5aa765d61d8327deb882cf99 |
| charlie  | d8578edf8458ce06fbc5bb76a58c5ca4 |
+----------+----------------------------------+
```

看起来安全多了？**错！**

## MD5 的致命缺陷

### 缺陷一：彩虹表攻击

黑客们很聪明。既然 MD5 是确定性的（同样的输入总是产生同样的输出），那我提前把常见密码的 MD5 值都算好，做成一张表：

```text
Rainbow Table (partial):
+----------+----------------------------------+
| password | MD5 hash                         |
+----------+----------------------------------+
| 123456   | e10adc3949ba59abbe56e057f20f883e |
| password | 5f4dcc3b5aa765d61d8327deb882cf99 |
| 12345678 | 25d55ad283aa400af464c76d713c07ad |
| qwerty   | d8578edf8458ce06fbc5bb76a58c5ca4 |
| ...      | ...                              |
| (billions of entries)                       |
+----------+----------------------------------+
```

有了这张表，破解就变成了"查表"：

```text
黑客拿到数据库：
张三的密码哈希 = e10adc3949ba59abbe56e057f20f883e

查彩虹表：
e10adc3949ba59abbe56e057f20f883e → 123456

破解完成！用时：0.001 秒
```

**现实中的彩虹表有多大？** 有的彩虹表包含数百 GB 的预计算数据，覆盖了几乎所有 8 位以下的密码组合。

### 缺陷二：MD5 太快了

MD5 设计的初衷是**快速校验文件完整性**，不是用来保护密码的。

现代显卡（GPU）计算 MD5 的速度：

```text
一块普通 GPU：每秒 100 亿次 MD5 计算

破解 6 位纯数字密码（100 万种可能）：
100万 ÷ 100亿 = 0.0001 秒

破解 8 位小写字母密码（2000 亿种可能）：
2000亿 ÷ 100亿 = 20 秒
```

这意味着：**弱密码在 MD5 面前形同虚设。**

### 缺陷三：相同密码 = 相同哈希

如果两个用户都用 "123456" 作为密码：

```text
+----------+----------------------------------+
| alice    | e10adc3949ba59abbe56e057f20f883e |
| bob      | e10adc3949ba59abbe56e057f20f883e | <- same!
+----------+----------------------------------+
```

黑客一看就知道：这两个人用的是同一个密码。破解一个 = 破解两个。

## 加点盐？

聪明的程序员想出了"加盐"（Salt）的办法：

```text
Registration:
salt = random "x7k2m"
store MD5("x7k2m" + "123456") = "a8f5f167f44f4964e6c998dee827110c"

Database:
+----------+-------+----------------------------------+
| username | salt  | password_hash                    |
+----------+-------+----------------------------------+
| alice    | x7k2m | a8f5f167f44f4964e6c998dee827110c |
| bob      | p9n3q | b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7 |
+----------+-------+----------------------------------+
```

现在即使两个人密码相同，哈希值也不同了。彩虹表也失效了（因为每个用户的盐不同）。

**但这仍然不够！**

问题依然是：**MD5 太快了。**

黑客可以针对每个用户单独暴力破解：

```text
目标：张三，盐 = "x7k2m"

尝试：MD5("x7k2m" + "000000") → 不对
尝试：MD5("x7k2m" + "000001") → 不对
...
尝试：MD5("x7k2m" + "123456") → 匹配！

用时：即使加了盐，GPU 暴力破解 6 位密码仍只需零点几秒
```

## MD5 的墓志铭

2004 年，中国密码学家王小云教授发表论文，展示了 MD5 的碰撞攻击方法。这意味着 MD5 在密码学意义上已经"死亡"。

```text
MD5 时间线：
1991 年：MD5 发明
1996 年：发现理论弱点
2004 年：王小云证明可快速碰撞
2008 年：利用 MD5 碰撞伪造 SSL 证书
2012 年：LinkedIn 泄露事件，MD5 哈希被批量破解
至今：仍有网站在用 MD5...（请不要这样做）
```

## 我们学到了什么？

MD5 存储密码的失败教给我们几个关键教训：

| 问题 | 为什么是问题 |
|-----|------------|
| 太快 | 攻击者可以每秒尝试数十亿次 |
| 确定性 | 相同密码 = 相同哈希，便于批量攻击 |
| 无盐 | 彩虹表可以预计算 |
| 为速度设计 | MD5 本就不是为密码设计的 |

## 正确的思路是什么？

我们需要的是：

```text
❌ MD5：快，为文件校验设计
        ↓ 应该改成 ↓
✅ 慢哈希：故意很慢，专为密码设计
```

如果哈希计算需要 0.1 秒而不是 0.0000001 秒：

```text
破解 6 位纯数字密码：
快哈希：100万 × 0.0000001秒 = 0.1 秒
慢哈希：100万 × 0.1秒 = 100000 秒 ≈ 28 小时

破解 8 位混合密码：
快哈希：几分钟
慢哈希：几千年
```

这就引出了我们下一篇的主角：**Argon2** —— 专门为密码设计的"慢哈希"算法。

---

## 总结

```text
密码存储进化：

明文存储        →  MD5 哈希      →  加盐 MD5     →  ???
"裸奔"            "穿了件纸衣服"    "纸衣服加了个口袋"   待续...

安全性：0         安全性：20       安全性：40
```

MD5 不是坏算法，只是**用错了地方**。它适合快速校验文件是否被篡改，不适合保护密码。

如果你的网站还在用 MD5 存密码，请立即停止，换用 Argon2 或 bcrypt。这不是建议，是**必须**。

---

*下一篇：[Argon2：专为密码设计的"慢哈希"算法](/posts/password-evolution-2-argon2/)*

*本系列：*
1. *MD5：一部血泪史（本篇）*
2. *[Argon2：慢哈希的艺术](/posts/password-evolution-2-argon2/)*
3. *[SRP：零知识证明风格的认证](/posts/password-evolution-3-srp/)*
4. *[OPAQUE：防离线破解的终极方案](/posts/password-evolution-4-opaque/)*
